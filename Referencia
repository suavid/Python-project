# !IMPORTANTE: ESTE ARCHIVO ES MODIFICABLE, NO SE PERMITE BORRAR PARTES DE EL, SOLO AGREGAR, 
# A PESAR QUE ALGUNA FUNCION SEA REMOVIDA POR MOTIVOS DIDACTICOS ES PREFERIBLE QUE LO YA
# AGREGADO SE MANTENGA

# NOTA: lo que aparece entre comillas simples ('') representa un nombre de variable que es
# arbitrario, es decir, se decide cuando se escribe el codigo

# Agrego partes importantes del codigo que se van utilizando en el programa para que sea mas facil que 
# puedan seguir colaborando con el desarrollo de este proyecto y les sea mas facil entender el codigo.

# 1-) Metodo main() es el que inicializa los eventos de las ventanas, atravez del objeto gtk
#     hacemos la llamada a gtk.main()

	def main(self):
		gtk.main()

# Esto da por finalizado el metodo que activa los eventos de la ventana 

# 2-) Otra parte importante del codigo es la creacion del objeto, la instancia de la clase ventana
#     con un if se verifica que el programa sea ejecutado de manera correcta por el interprete python
#     si esto se cumple se crea el objeto y se invoca al metodo main() de la clase ventana. Referenciar 
#     al codigo para mayor comprension  

	if __name__=="__main__":
		mainFrame = ventana()
		mainFrame.main()

# 3-) Esta es una funcion miembro de la clase, es llamada al hacer click en el boton cerrar de la ventana
#     si develve True la ventana no se cierra, si devuelve False llamara al evento destroy para cerrar la ventana

	def delete(self, widget, data = None):
			return False

# 4-) Esta es la funcion llamada por el evento destroy que cierra definitivamente la ventana, contrario a 
      main()

	def close(self, widget, data = None):
		gtk.main_quit()
 
# 5-) Por el momento aqui se mantienen las funciones principales del programa, respetar la sintaxis
	
	def __init__(self):

# 6-) se crea un varible llamada window, (El nombre es arbitrario), esta almacenara una referencia a la ventana
#      por medio de gtk se crea la ventana nueva, WINDOW_TOPLEVEL indica que los contronos serán manejados por el 
#      gestor de ventanas del OS
	
	self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)

# 7-) homogeneous es el parametro que indica si todos los elementos empaquetados en la caja tendrán 
#     las mismas dimensiones, Las funciones que nos permiten crear una caja nueva son:

  	'hbox' = gtk.HBox(homogeneous=FALSE, spacing=0)

  	'vbox' = gtk.VBox(homogeneous=FALSE, spacing=0)

# 'box' hace referencia a la variable que almacena la caja creada.    

	'box'.pack_start(child, expand=TRUE, fill=TRUE, padding=0)

	'box'.pack_end(child, expand=TRUE, fill=TRUE, padding=0)

# child, expand, fill y padding son palabras clave (argumentos con nombre). 
# Los argumentos expand, fill y padding tienen los valores predeterminados 
# (o "por defecto") mostrados arriba. El argumento child debe especificarse 
# obligatoriamente al no tener un valor predeterminado.

# 8-) Creacion de una tabla para empaquetar

	'table' = gtk.Table(rows=1, columns=1, homogeneous=FALSE)

# Obsérvese que el sistema de coordenadas tiene su orgien en la esquina superior 
# izquierda. Para introducir un control en una caja, se usa el siguiente método:

  	table.attach(child, left_attach, right_attach, top_attach, bottom_attach,
	xoptions=EXPAND|FILL, yoptions=EXPAND|FILL, xpadding=0, ypadding=0)

# Los pasos generales para usar un control (widget) en PyGTK son:

  #  Se llama a gtk.* (una de las múltiples funciones para crear un nuevo control, y que se detallan en esta sección.
  #  Se conectan todas la señales y eventos que queramos usar a los manejadores apropiados.
  #  Se establecen los atributos del control.
  #  Se empaqueta el control dentro de un contenedor usando una llamada como gtk.Container.add() o gtk.Box.pack_start().
  #  Se llama a gtk.Widget.show() en el control.
